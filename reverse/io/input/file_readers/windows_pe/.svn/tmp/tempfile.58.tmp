#include "PE_Optional_Header_T.h"
#include "PE_Subsystem.h"
#include "libreverse/io/Byte_Converter.h"
#include <sstream>
#include <boost/format.hpp>
#include <iostream>
#include <iomanip>
#include "libreverse/Trace.h"

using namespace libreverse::api;
using namespace libreverse::trace;

namespace libreverse
{
    namespace wpef_module
    {

        template <boost::uint32_t bitsize>
        boost::uint16_t const PE_Optional_Header<bitsize>::ROM_IMAGE = 0x0107;

        template <boost::uint32_t bitsize>
        boost::uint16_t const PE_Optional_Header<bitsize>::PE_EXECUTABLE = 0x010B;

        template <boost::uint32_t bitsize>
        boost::uint16_t const PE_Optional_Header<bitsize>::PE_PLUS_EXECUTABLE = 0x020B;

        template <boost::uint32_t bitsize>
        PE_Optional_Header<bitsize>::PE_Optional_Header()
                : m_magic ( 0 ),
                m_major_linker_version ( 0 ),
                m_minor_linker_version ( 0 ),
                m_size_of_code ( 0 ),
                m_size_of_init_data ( 0 ),
                m_size_of_uninit_data ( 0 ),
                m_addr_of_entry_point ( 0 ),
                m_base_of_code ( 0 ),
                m_base_of_data ( 0 ),
                m_image_base ( 0 ),
                m_section_alignment ( 0 ),
                m_file_alignment ( 0 ),
                m_major_operating_system_version ( 0 ),
                m_minor_operating_system_version ( 0 ),
                m_major_image_version ( 0 ),
                m_minor_image_version ( 0 ),
                m_major_subsystem_version ( 0 ),
                m_minor_subsystem_version ( 0 ),
                m_win32_version_value ( 0 ),
                m_size_of_image ( 0 ),
                m_size_of_headers ( 0 ),
                m_checksum ( 0 ),
                m_subsystem ( 0 ),
                m_dll_characteristics ( 0 ),
                m_size_of_stack_reserve ( 0 ),
                m_size_of_stack_commit ( 0 ),
                m_size_of_heap_reserve ( 0 ),
                m_size_of_heap_commit ( 0 ),
                m_loader_flags ( 0 ),
                m_number_of_rva_and_sizes ( 0 ),
                m_export_table_address ( 0 ),
                m_export_table_size ( 0 ),
                m_import_table_address ( 0 ),
                m_import_table_size ( 0 ),
                m_resource_table_address ( 0 ),
                m_resource_table_size ( 0 ),
                m_exception_table_address ( 0 ),
                m_exception_table_size ( 0 ),
                m_certificate_table_address ( 0 ),
                m_certificate_table_size ( 0 ),
                m_base_relocation_table_address ( 0 ),
                m_base_relocation_table_size ( 0 ),
                m_debug_table_address ( 0 ),
                m_debug_table_size ( 0 ),
                m_architecture_address ( 0 ),
                m_architecture_size ( 0 ),
                m_global_ptr_address ( 0 ),
                m_global_ptr_size ( 0 ),
                m_thread_local_storage_table_address ( 0 ),
                m_thread_local_storage_table_size ( 0 ),
                m_load_config_table_address ( 0 ),
                m_load_config_table_size ( 0 ),
                m_bound_import_address ( 0 ),
                m_bound_import_size ( 0 ),
                m_import_address_table_address ( 0 ),
                m_import_address_table_size ( 0 ),
                m_delay_import_descriptor_address ( 0 ),
                m_delay_import_descriptor_size ( 0 ),
                m_clr_runtime_header_address ( 0 ),
                m_clr_runtime_header_size ( 0 ),
                m_reserved_address ( 0 ),
                m_reserved_size ( 0 )
        {}

        /*!
         * \brief Convert the header data into a string representation
         * \return String representation of header data
         */
        template <boost::uint32_t bitsize>
        std::string
        PE_Optional_Header<bitsize>::to_String ( void ) const
        {
            std::stringstream output_str;

            output_str << "PE Optional Header:" << std::endl;

            output_str << boost::format ( "  Magic:                      %1%" ) %
            boost::io::group ( std::hex,
                               m_magic )
            << std::endl;

            output_str << boost::format ( "  Linker version:             %1%.%2%" ) %
            static_cast<boost::uint16_t> ( m_major_linker_version ) %
            boost::io::group ( std::setfill ( '0' ),
                               std::setw ( 2 ),
                               static_cast<boost::uint16_t> ( m_minor_linker_version ) )
            << std::endl;

            output_str << boost::format ( "  Size of code:               %1X" ) %
            m_size_of_code
            << std::endl;

            output_str << boost::format ( "  Size of Initialized Data:   %1X" ) %
            m_size_of_init_data
            << std::endl;

            output_str << boost::format ( "  Size of Uninitialized Data: %1X" ) %
            m_size_of_uninit_data
            << std::endl;

            output_str << boost::format ( "  Address of entry point:     %1X" ) %
            m_addr_of_entry_point
            << std::endl;

            output_str << boost::format ( "  Base of code:               %1X" ) %
            m_base_of_code
            << std::endl;

            if ( bitsize == 32 )
            {
                output_str << boost::format ( "  Base of data:               %1X" ) %
                m_base_of_data
                << std::endl;
            }

            output_str << boost::format ( "  Base of image:              %1X" ) %
            m_image_base
            << std::endl;

            output_str << boost::format ( "  Section alignment:          %1X" ) %
            m_section_alignment
            << std::endl;

            output_str << boost::format ( "  File alignment:             %1X" ) %
            m_file_alignment
            << std::endl;

            output_str << boost::format ( "  OS System version:          %1%.%2%" ) %
            m_major_operating_system_version %
            boost::io::group ( std::setfill ( '0' ),
                               std::setw ( 2 ),
                               m_minor_operating_system_version )
            << std::endl;

            output_str << boost::format ( "  Image version:              %1%.%2%" ) %
            m_major_image_version %
            boost::io::group ( std::setfill ( '0' ),
                               std::setw ( 2 ),
                               m_minor_image_version )
            << std::endl;

            output_str << boost::format ( "  Subsystem version:          %1%.%2%" ) %
            m_major_subsystem_version %
            boost::io::group ( std::setfill ( '0' ),
                               std::setw ( 2 ),
                               m_minor_subsystem_version )
            << std::endl;

            output_str << "  Win32 Version:              "
            << m_win32_version_value
            << std::endl;

            output_str << boost::format ( "  Size of image:              %1X" ) %
            m_size_of_image
            << std::endl;

            output_str << boost::format ( "  Size of headers:            %1X" ) %
            m_size_of_headers
            << std::endl;

            output_str << boost::format ( "  Checksum:                   %1X" ) %
            m_checksum
            << std::endl;

            output_str << boost::format ( "  Sub-system:                 %1% (%2%)" )
            % m_subsystem
            % PE_Subsystem::get_String_Name ( m_subsystem )
            << std::endl;

            output_str << boost::format ( "  DLL characteristics:        %1X" ) %
            m_dll_characteristics
            << std::endl;

            output_str << boost::format ( "  Stack reserve size:         %1X" ) %
            m_size_of_stack_reserve
            << std::endl;

            output_str << boost::format ( "  Stack commit size:          %1X" ) %
            m_size_of_stack_commit
            << std::endl;

            output_str << boost::format ( "  Heap reserve size:          %1X" ) %
            m_size_of_heap_reserve
            << std::endl;

            output_str << boost::format ( "  Heap commit size:           %1X" ) %
            m_size_of_heap_commit
            << std::endl;

            output_str << boost::format ( "  Loader flags:               %1X" ) %
            m_loader_flags
            << std::endl;

            output_str << boost::format ( "  Number of RVA and sizes:    %1X" ) %
            m_number_of_rva_and_sizes
            << std::endl;

            output_str << boost::format ( "  Export table:                  %1% [ %2% ]" ) %
            boost::io::group ( std::hex,
                               m_export_table_address ) %
            boost::io::group ( std::hex,
                               m_export_table_size )
            << std::endl;

            output_str << boost::format ( "  Import table:                  %1% [ %2% ]" ) %
            boost::io::group ( std::hex,
                               m_import_table_address ) %
            boost::io::group ( std::hex,
                               m_import_table_size )
            << std::endl;

            output_str << boost::format ( "  Resource table:                %1% [ %2% ]" ) %
            boost::io::group ( std::hex,
                               m_resource_table_address ) %
            boost::io::group ( std::hex,
                               m_resource_table_size )
            << std::endl;

            output_str << boost::format ( "  Exception table:               %1% [ %2% ]" ) %
            boost::io::group ( std::hex,
                               m_exception_table_address ) %
            boost::io::group ( std::hex,
                               m_exception_table_size )
            << std::endl;

            output_str << boost::format ( "  Certificate table:             %1% [ %2% ]" ) %
            boost::io::group ( std::hex,
                               m_certificate_table_address ) %
            boost::io::group ( std::hex,
                               m_certificate_table_size )
            << std::endl;

            output_str << boost::format ( "  Base Relocation table:         %1% [ %2% ]" ) %
            boost::io::group ( std::hex,
                               m_base_relocation_table_address ) %
            boost::io::group ( std::hex,
                               m_base_relocation_table_size )
            << std::endl;

            output_str << boost::format ( "  Debug table:                   %1% [ %2% ]" ) %
            boost::io::group ( std::hex,
                               m_debug_table_address ) %
            boost::io::group ( std::hex,
                               m_debug_table_size )
            << std::endl;

            output_str << boost::format ( "  Architecture:                  %1% [ %2% ]" ) %
            boost::io::group ( std::hex,
                               m_architecture_address ) %
            boost::io::group ( std::hex,
                               m_architecture_size )
            << std::endl;

            output_str << boost::format ( "  Global Pointer table:          %1% [ %2% ]" ) %
            boost::io::group ( std::hex,
                               m_global_ptr_address ) %
            boost::io::group ( std::hex,
                               m_global_ptr_size )
            << std::endl;

            output_str << boost::format ( "  Thread Local Storage table:    %1% [ %2% ]" ) %
            boost::io::group ( std::hex,
                               m_thread_local_storage_table_address ) %
            boost::io::group ( std::hex,
                               m_thread_local_storage_table_size )
            << std::endl;

            output_str << boost::format ( "  Load Config table:             %1% [ %2% ]" ) %
            boost::io::group ( std::hex,
                               m_load_config_table_address ) %
            boost::io::group ( std::hex,
                               m_load_config_table_size )
            << std::endl;

            output_str << boost::format ( "  Bound Import table:            %1% [ %2% ]" ) %
            boost::io::group ( std::hex,
                               m_bound_import_address ) %
            boost::io::group ( std::hex,
                               m_bound_import_size )
            << std::endl;

            output_str << boost::format ( "  Import Address table:          %1% [ %2% ]" ) %
            boost::io::group ( std::hex,
                               m_import_address_table_address ) %
            boost::io::group ( std::hex,
                               m_import_address_table_size )
            << std::endl;

            output_str << boost::format ( "  Delay Import Descriptor table: %1% [ %2% ]" ) %
            boost::io::group ( std::hex,
                               m_delay_import_descriptor_address ) %
            boost::io::group ( std::hex,
                               m_delay_import_descriptor_size )
            << std::endl;

            output_str << boost::format ( "  CLR Runtime table:             %1% [ %2% ]" ) %
            boost::io::group ( std::hex,
                               m_clr_runtime_header_address ) %
            boost::io::group ( std::hex,
                               m_clr_runtime_header_size )
            << std::endl;

            output_str << boost::format ( "  Reserved:                      %1% [ %2% ]" ) %
            boost::io::group ( std::hex,
                               m_reserved_address ) %
            boost::io::group ( std::hex,
                               m_reserved_size )
            << std::endl;

            return output_str.str();
        }

        template <boost::uint32_t bitsize>
        typename Type_Mapper<bitsize>::arch_t
        PE_Optional_Header<bitsize>::get_size ( void ) const
        {
            return bitsize;
        }

        /*!
         * \brief Convert the bit order of the stored data if host and data
         * endian types differ
         *
         * \param host_endian Endian type of host
         * \param data_endian Endian type of data
         */
        template <boost::uint32_t bitsize>
        void
        PE_Optional_Header<bitsize>::convert ()
        {
            io::Byte_Converter::convert ( m_size_of_code );
            io::Byte_Converter::convert ( m_size_of_init_data );
            io::Byte_Converter::convert ( m_size_of_uninit_data );
            io::Byte_Converter::convert ( m_addr_of_entry_point );
            io::Byte_Converter::convert ( m_base_of_code );
            if ( bitsize == 32 )
            {
                io::Byte_Converter::convert ( m_base_of_data );
            }
            io::Byte_Converter::convert ( m_image_base );
            io::Byte_Converter::convert ( m_section_alignment );
            io::Byte_Converter::convert ( m_file_alignment );
            io::Byte_Converter::convert ( m_major_operating_system_version );
            io::Byte_Converter::convert ( m_minor_operating_system_version );
            io::Byte_Converter::convert ( m_major_image_version );
            io::Byte_Converter::convert ( m_minor_image_version );
            io::Byte_Converter::convert ( m_major_subsystem_version );
            io::Byte_Converter::convert ( m_minor_subsystem_version );
            io::Byte_Converter::convert ( m_win32_version_value );
            io::Byte_Converter::convert ( m_size_of_image );
            io::Byte_Converter::convert ( m_size_of_headers );
            io::Byte_Converter::convert ( m_checksum );
            io::Byte_Converter::convert ( m_subsystem );
            io::Byte_Converter::convert ( m_dll_characteristics );
            io::Byte_Converter::convert ( m_size_of_stack_reserve );
            io::Byte_Converter::convert ( m_size_of_stack_commit );
            io::Byte_Converter::convert ( m_size_of_heap_reserve );
            io::Byte_Converter::convert ( m_size_of_heap_commit );
            io::Byte_Converter::convert ( m_loader_flags );
            io::Byte_Converter::convert ( m_number_of_rva_and_sizes );
            io::Byte_Converter::convert ( m_export_table_address );
            io::Byte_Converter::convert ( m_export_table_size );
            io::Byte_Converter::convert ( m_import_table_address );
            io::Byte_Converter::convert ( m_import_table_size );
            io::Byte_Converter::convert ( m_resource_table_address );
            io::Byte_Converter::convert ( m_resource_table_size );
            io::Byte_Converter::convert ( m_exception_table_address );
            io::Byte_Converter::convert ( m_exception_table_size );
            io::Byte_Converter::convert ( m_certificate_table_address );
            io::Byte_Converter::convert ( m_certificate_table_size );
            io::Byte_Converter::convert ( m_base_relocation_table_address );
            io::Byte_Converter::convert ( m_base_relocation_table_size );
            io::Byte_Converter::convert ( m_debug_table_address );
            io::Byte_Converter::convert ( m_debug_table_size );
            io::Byte_Converter::convert ( m_architecture_address );
            io::Byte_Converter::convert ( m_architecture_size );
            io::Byte_Converter::convert ( m_global_ptr_address );
            io::Byte_Converter::convert ( m_global_ptr_size );
            io::Byte_Converter::convert ( m_thread_local_storage_table_address );
            io::Byte_Converter::convert ( m_thread_local_storage_table_size );
            io::Byte_Converter::convert ( m_load_config_table_address );
            io::Byte_Converter::convert ( m_load_config_table_size );
            io::Byte_Converter::convert ( m_bound_import_address );
            io::Byte_Converter::convert ( m_bound_import_size );
            io::Byte_Converter::convert ( m_import_address_table_address );
            io::Byte_Converter::convert ( m_import_address_table_size );
            io::Byte_Converter::convert ( m_delay_import_descriptor_address );
            io::Byte_Converter::convert ( m_delay_import_descriptor_size );
            io::Byte_Converter::convert ( m_clr_runtime_header_address );
            io::Byte_Converter::convert ( m_clr_runtime_header_size );
            io::Byte_Converter::convert ( m_reserved_address );
            io::Byte_Converter::convert ( m_reserved_size );
        }

        template <boost::uint32_t bitsize>
        bool
        PE_Optional_Header<bitsize>::is_PE_File ( void )
        {
            return ( m_magic == PE_Header<bitsize>::PE_MAGIC_SIGNATURE );
        }

        template <boost::uint32_t bitsize>
        boost::uint16_t
        PE_Optional_Header<bitsize>::get_Magic_Value ( void ) const
        {
            return m_magic;
        }

        template <boost::uint32_t bitsize>
        boost::uint8_t
        PE_Optional_Header<bitsize>::get_Major_Linker_Version ( void ) const
        {
            return m_major_linker_version;
        }

        template <boost::uint32_t bitsize>
        boost::uint8_t
        PE_Optional_Header<bitsize>::get_Minor_Linker_Version ( void ) const
        {
            return m_minor_linker_version;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Size_Of_Code ( void ) const
        {
            return m_size_of_code;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Size_Of_Init_Data ( void ) const
        {
            return m_size_of_init_data;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Size_Of_Uninitialized_Data ( void ) const
        {
            return m_size_of_uninit_data;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Entry_Point ( void ) const
        {
            return m_addr_of_entry_point;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Base_Of_Code ( void ) const
        {
            return m_base_of_code;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Base_Of_Data ( void ) const
        {
            if ( bitsize == 64 )
            {
                Trace::write_Trace
                ( TraceArea::IO,
                  TraceLevel::ERROR,
                  "A PE32+ header does not have a base_of_data field." );
            }

            return m_base_of_data;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Image_Base ( void ) const
        {
            return m_image_base;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Section_Alignment ( void ) const
        {
            return m_section_alignment;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_File_Alignment ( void ) const
        {
            return m_file_alignment;
        }

        template <boost::uint32_t bitsize>
        boost::uint16_t
        PE_Optional_Header<bitsize>::get_Major_Operating_System_Version ( void ) const
        {
            return m_major_operating_system_version;
        }

        template <boost::uint32_t bitsize>
        boost::uint16_t
        PE_Optional_Header<bitsize>::get_Minor_Operating_System_Version ( void ) const
        {
            return m_minor_operating_system_version;
        }

        template <boost::uint32_t bitsize>
        boost::uint16_t
        PE_Optional_Header<bitsize>::get_Major_Image_Version ( void ) const
        {
            return m_major_image_version;
        }

        template <boost::uint32_t bitsize>
        boost::uint16_t
        PE_Optional_Header<bitsize>::get_Minor_Image_Version ( void ) const
        {
            return m_minor_image_version;
        }

        template <boost::uint32_t bitsize>
        boost::uint16_t
        PE_Optional_Header<bitsize>::get_Major_Subsystem_Version ( void ) const
        {
            return m_major_subsystem_version;
        }

        template <boost::uint32_t bitsize>
        boost::uint16_t
        PE_Optional_Header<bitsize>::get_Minor_Subsystem_Version ( void ) const
        {
            return m_minor_subsystem_version;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Win32_Version_Value ( void ) const
        {
            return m_win32_version_value;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Size_Of_Image ( void ) const
        {
            return m_size_of_image;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Size_Of_Headers ( void ) const
        {
            return m_size_of_headers;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Checksum ( void ) const
        {
            return m_checksum;
        }

        template <boost::uint32_t bitsize>
        boost::uint16_t
        PE_Optional_Header<bitsize>::get_Subsystem ( void ) const
        {
            return m_subsystem;
        }

        template <boost::uint32_t bitsize>
        boost::uint16_t
        PE_Optional_Header<bitsize>::get_DLL_Characteristics ( void ) const
        {
            return m_dll_characteristics;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Size_Of_Stack_Reserve ( void ) const
        {
            return m_size_of_stack_reserve;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Size_Of_Stack_Commit ( void ) const
        {
            return m_size_of_stack_commit;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Size_Of_Heap_Reserve ( void ) const
        {
            return m_size_of_heap_reserve;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Size_Of_Heap_Commit ( void ) const
        {
            return m_size_of_heap_commit;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Loader_Flags ( void ) const
        {
            return m_loader_flags;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Number_Of_RVA_And_Sizes ( void ) const
        {
            return m_number_of_rva_and_sizes;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Export_Table_Address ( void ) const
        {
            return m_export_table_address;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Export_Table_Size ( void ) const
        {
            return m_export_table_size;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Import_Table_Address ( void ) const
        {
            return m_import_table_address;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Import_Table_Size ( void ) const
        {
            return m_import_table_size;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Resource_Table_Address ( void ) const
        {
            return m_resource_table_address;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Resource_Table_Size ( void ) const
        {
            return m_resource_table_size;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Exception_Table_Address ( void ) const
        {
            return m_exception_table_address;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Exception_Table_Size ( void ) const
        {
            return m_exception_table_size;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Certificate_Table_Address ( void ) const
        {
            return m_certificate_table_address;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Certificate_Table_Size ( void ) const
        {
            return m_certificate_table_size;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Base_Relocation_Table_Address ( void ) const
        {
            return m_base_relocation_table_address;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Base_Relocation_Table_Size ( void ) const
        {
            return m_base_relocation_table_size;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Debug_Table_Address ( void ) const
        {
            return m_debug_table_address;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Debug_Table_Size ( void ) const
        {
            return m_debug_table_size;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Architecture_Address ( void ) const
        {
            return m_architecture_address;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Architecture_Size ( void ) const
        {
            return m_architecture_size;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Global_Ptr_Address ( void ) const
        {
            return m_global_ptr_address;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Global_Ptr_Size ( void ) const
        {
            return m_global_ptr_size;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Thread_Local_Storage_Table_Address ( void ) const
        {
            return m_thread_local_storage_table_address;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Thread_Local_Storage_Table_Size ( void ) const
        {
            return m_thread_local_storage_table_size;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Load_Config_Table_Address ( void ) const
        {
            return m_load_config_table_address;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Load_Config_Table_Size ( void ) const
        {
            return m_load_config_table_size;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Bound_Import_Address ( void ) const
        {
            return m_bound_import_address;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Bound_Import_Size ( void ) const
        {
            return m_bound_import_size;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Import_Address_Table_Address ( void ) const
        {
            return m_import_address_table_address;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Import_Address_Table_Size ( void ) const
        {
            return m_import_address_table_size;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Delay_Import_Descriptor_Address ( void ) const
        {
            return m_delay_import_descriptor_address;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Delay_Import_Descriptor_Size ( void ) const
        {
            return m_delay_import_descriptor_size;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Clr_Runtime_Header_Address ( void ) const
        {
            return m_clr_runtime_header_address;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Clr_Runtime_Header_Size ( void ) const
        {
            return m_clr_runtime_header_size;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Reserved_Address ( void ) const
        {
            return m_reserved_address;
        }

        template <boost::uint32_t bitsize>
        boost::uint32_t
        PE_Optional_Header<bitsize>::get_Reserved_Size ( void ) const
        {
            return m_reserved_size;
        }

    } /* namespace wpef_module */
} /* namespace libreverse */
