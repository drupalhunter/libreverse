#include "Elf_Header_T.h"
#include "libreverse/Trace.h"

using namespace libreverse::api;
using namespace libreverse::trace;

namespace libreverse { namespace elf_module {

    template <boost::uint32_t bitsize>
    Elf_Header<bitsize>::Elf_Header()
        : m_base_address_set ( false ),
          m_base_address ( 0 ),
          m_dyn_hdr ( new Elf_Dynamic_Header<bitsize>() )
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Inside Elf_Header constructor" );
    }

    template <boost::uint32_t bitsize>
    Elf_Header<bitsize>::~Elf_Header()
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Inside Elf_Header destructor" );
    }

    template <boost::uint32_t bitsize>
    void Elf_Header<bitsize>::init ()
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Inside Elf_Header::init" );
    }

    template <boost::uint32_t bitsize>
    boost::uint32_t
    Elf_Header<bitsize>::get_size () const
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Inside Elf_Header::get_size" );

        return bitsize;
    }

    template <boost::uint32_t bitsize>
    void
    Elf_Header<bitsize>::convert ()
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Entering Elf_Header::convert" );

        m_file_hdr->convert ();

        for ( typename elf_types::Elf_Header<bitsize>::Program_Header_List_t::iterator pos_ptr = m_prg_hdrs.begin();
              pos_ptr != m_prg_hdrs.end();
              ++pos_ptr )
            {
                (*pos_ptr)->convert ();
            }

        for ( typename elf_types::Elf_Header<bitsize>::Section_Header_Map_t::iterator pos_ptr = m_sec_hdrs.begin();
              pos_ptr != m_sec_hdrs.end();
              ++pos_ptr )
            {
                typename elf_types::Elf_Section_Header<bitsize>::ptr_t sec_ptr = (*pos_ptr).second;
                sec_ptr->convert ();
            }

        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Exiting Elf_Header::convert" );

    }

    template <boost::uint32_t bitsize>
    std::string
    Elf_Header<bitsize>::to_String ()
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Entering Elf_Header::to_String" );

        std::stringstream output_str;

        output_str << m_file_hdr->to_String() << std::endl;

        output_str << "------------------------------------------------"
                   << std::endl
                   << "             PROGRAM HEADERS"
                   << std::endl
                   << "------------------------------------------------"
                   << std::endl;

        output_str << boost::format ("  %|-15| %|-10| %|-12| %|-12| %|-8| %|-10| %|-4| %|-5|")
            % "Header"
            % "Offset"
            % "VAddr"
            % "PAddr"
            % "Filesz"
            % "Memsz"
            % "Flg"
            % "Align" << std::endl;

        for ( typename elf_types::Elf_Header<bitsize>::Program_Header_List_t::iterator pos_ptr = m_prg_hdrs.begin();
              pos_ptr != m_prg_hdrs.end();
              ++pos_ptr )
            {
                output_str << (*pos_ptr)->to_String() << std::endl;
            }

        output_str << std::endl;

        output_str << "------------------------------------------------"
                   << std::endl
                   << "             SECTION HEADERS"
                   << std::endl
                   << "------------------------------------------------"
                   << std::endl;

        output_str << boost::format(" %|-17| %|-8| %|-8| %|-8| %|-8| %|-3|")
	    % "Name"
            % "Addr"
            % "Offset"
            % "Size"
            % "Info"
            % "Addralign" << std::endl;

        for ( typename elf_types::Elf_Header<bitsize>::Section_Header_Map_t::iterator pos_ptr
                  = m_sec_hdrs.begin();
              pos_ptr != m_sec_hdrs.end();
              ++pos_ptr )
            {
                typename elf_types::Elf_Section_Header<bitsize>::ptr_t sec_ptr = (*pos_ptr).second;
                output_str << sec_ptr->to_String() << std::endl;
            }

        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Exiting Elf_Header::to_String" );

        return output_str.str();
    }

    template <boost::uint32_t bitsize>
    void
    Elf_Header<bitsize>::get_Text_String ( io_types::Text_Data::data_type* output )
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Entering Elf_Header::get_Text_String" );

        m_file_hdr->get_Text_String ( output );
        
        for ( typename elf_types::Elf_Header<bitsize>::Section_Header_Map_t::iterator pos_ptr = m_sec_hdrs.begin();
              pos_ptr != m_sec_hdrs.end();
              ++pos_ptr )
            {
                typename elf_types::Elf_Section_Header<bitsize>::ptr_t sec_ptr = (*pos_ptr).second;
                sec_ptr->get_Text_String ( output );
            }

        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Exiting Elf_Header::get_Text_String" );
    }

    template <boost::uint32_t bitsize>
    Elf_File_Header<bitsize> const&
    Elf_Header<bitsize>::get_File_Header (void) const
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Exiting Elf_Header::get_File_Header" );

        return *m_file_hdr;
    }

    template <boost::uint32_t bitsize>
    bool
    Elf_Header<bitsize>::is_File_Header_Set (void) const
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Entering Elf_Header::is_File_Header_Set" );

        bool result = true;

        if ( m_file_hdr.get() == 0 )
            {
                result = false;
            }

        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Exiting Elf_Header::is_File_Header_Set" );

        return result;
    }

    template <boost::uint32_t bitsize>
    void Elf_Header<bitsize>::set_File_Header ( typename elf_types::Elf_File_Header<bitsize>::ptr_t hdr )
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Entering Elf_Header::set_File_Header" );

        m_file_hdr = hdr;

        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Exiting Elf_Header::set_File_Header" );
    }

    template <boost::uint32_t bitsize>
    Elf_Section_Header<bitsize> const&
    Elf_Header<bitsize>::get_Section_Header ( boost::uint16_t index ) const
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Entering Elf_Header::get_Section_Header (uint16)" );

        if ( index <= m_sec_hdrs.size() )
            {
                std::string name = m_sec_hdr_index[index];
                return this->get_Section_Header ( name );
            }
        else
            {
                std::cerr << "ERROR:" << std::endl
                          << "  Index: " << index << std::endl
                          << "  No of Section headers: " << m_sec_hdrs.size()
                          << std::endl;

                throw errors::File_Reader_Exception
                    (errors::File_Reader_Exception::OUT_OF_BOUNDS);
            }

        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Exiting Elf_Header::get_Section_Header (uint16)" );
    }

    template <boost::uint32_t bitsize>
    Elf_Section_Header<bitsize> const&
    Elf_Header<bitsize>::get_Section_Header ( std::string name ) const
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Entering Elf_Header::get_Section_Header (string)" );

        typename elf_types::Elf_Header<bitsize>::Section_Header_Map_t::const_iterator pos = m_sec_hdrs.find ( name );

        typename elf_types::Elf_Section_Header<bitsize>::ptr_t sec_ptr = (*pos).second;

        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Exiting Elf_Header::get_Section_Header (string)" );

        return *sec_ptr;
    }

    template <boost::uint32_t bitsize>
    typename elf_types::Elf_Header<bitsize>::Section_Header_Map_t::const_iterator
    Elf_Header<bitsize>::get_Section_Header_Begin (void) const
    {
        return m_sec_hdrs.begin();
    }

    template <boost::uint32_t bitsize>
    typename elf_types::Elf_Header<bitsize>::Section_Header_Map_t::const_iterator
    Elf_Header<bitsize>::get_Section_Header_End (void) const
    {
        return m_sec_hdrs.end();
    }

    template <boost::uint32_t bitsize>
    void Elf_Header<bitsize>::push_Back_Section_Header ( typename elf_types::Elf_Section_Header<bitsize>::ptr_t const sec_ptr )
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Entering Elf_Header::push_Back_Section_Header" );

        std::string section_name = sec_ptr->get_Section_String_Name();

        m_sec_hdrs.insert ( std::make_pair( section_name, sec_ptr ) );

        m_sec_hdr_index.push_back ( section_name );

        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Exiting Elf_Header::push_Back_Section_Header" );
    }

    template <boost::uint32_t bitsize>
    void Elf_Header<bitsize>::push_Back_Program_Header ( typename elf_types::Elf_Program_Header<bitsize>::ptr_t const prg )
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Entering Elf_Header::push_Back_Program_Header" );

        if ( ! m_base_address_set )
            {
                m_base_address_set = true;
                m_base_address = prg->get_Virtual_Address();
            }
        else if ( ( prg->get_Virtual_Address() < m_base_address ) && ( prg->get_Virtual_Address() != 0 ) )
            {
                m_base_address = prg->get_Virtual_Address();
            }
        else
            {
                // Do nothing
            }

        m_prg_hdrs.push_back ( prg );

        if (prg->get_Type() == Elf_Common::PT_LOAD)
            {
                m_instruction_prg_hdrs.push_back(prg);
            }

        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Exiting Elf_Header::push_Back_Program_Header" );
    }

    template <boost::uint32_t bitsize>
    void Elf_Header<bitsize>::push_Back_Relocation_Header ( typename elf_types::Elf_Relocation<bitsize>::ptr_t const rel )
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Entering Elf_Header::push_Back_Relocation_Header" );

        m_relocs.push_back(rel);

        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Exiting Elf_Header::push_Back_Relocation_Header" );
    }

    template <boost::uint32_t bitsize>
    void Elf_Header<bitsize>::push_Back_Relocation_Add_Header ( typename elf_types::Elf_Relocation_Add<bitsize>::ptr_t const rel )
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Entering Elf_Header::push_Back_Relocation_Add_Header" );

        m_relocs_add.push_back(rel);

        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Exiting Elf_Header::push_Back_Relocation_Add_Header" );

    }

    template <boost::uint32_t bitsize>
    bool Elf_Header<bitsize>::has_Section_Headers (void)
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Inside Elf_Header::has_Section_Headers" );

        return ( ! m_sec_hdrs.empty() );
    }

    template <boost::uint32_t bitsize>
    bool Elf_Header<bitsize>::has_Program_Headers (void)
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Inside Elf_Header::has_Program_Headers" );

        return ( !m_prg_hdrs.empty() );
    }

    template <boost::uint32_t bitsize>
    bool Elf_Header<bitsize>::has_Symbols (void)
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Inside Elf_Header::has_Symbols" );

        return (!m_symbol_table.empty());
    }

    template <boost::uint32_t bitsize>
    std::string const
    Elf_Header<bitsize>::get_Program_Header_String (void)
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Entering Elf_Header::get_Program_Header_String" );

        std::stringstream output;
        for ( typename elf_types::Elf_Header<bitsize>::Program_Header_List_t::iterator pos = m_prg_hdrs.begin();
              pos != m_prg_hdrs.end();
              ++pos )
            {
                output << (*pos)->to_String() << std::endl;
            }

        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Exiting Elf_Header::get_Program_Header_String" );

        return output.str();
    }

    /* NOTE: Possibly we can remove this function */
    template <boost::uint32_t bitsize>
    std::string const
    Elf_Header<bitsize>::get_Symbol_Token_String ( char const* string_table )
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Entering Elf_Header::get_Symbol_Token_String" );

        std::stringstream output;
        uint32_t counter = 0;

        for ( typename elf_types::Elf_Header<bitsize>::Elf_Symbol_List_t::iterator pos =  m_symbol_table.begin();
              pos != m_symbol_table.end();
              ++pos )
            {
                if ( m_file_hdr->get_String_Token_Index () != Elf_Common::SHN_UNDEF )
                    {
                        char* name = string_table + (*pos)->get_String_Token_Index();
                        (*pos)->set_Symbol_Name(std::string(name));
                    }

                output << boost::format("%1%: %2%") %
                    boost::io::group(std::setfill(' '), std::setw(7), counter) %
                    (*pos)->to_String() << std::endl;

                ++counter;
            }

        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Exiting Elf_Header::get_Symbol_Token_String" );

        return output.str();
    }

    template <boost::uint32_t bitsize>
    std::string const
    Elf_Header<bitsize>::get_Relocation_String (void)
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Entering Elf_Header::get_Relocation_String" );

        std::stringstream output;
        output << "  Number of symbols: " << m_relocs.size() << std::endl;

        for ( typename elf_types::Elf_Header<bitsize>::Elf_Relocation_List_t::iterator pos = m_relocs.begin();
              pos != m_relocs.end();
              ++pos )
            {
                output << (*pos)->to_String() << std::endl;
            }

        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Exiting Elf_Header::get_Relocation_String" );

        return output.str();
    }

    template <boost::uint32_t bitsize>
    std::string const
    Elf_Header<bitsize>::get_Relocation_Add_String (void)
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Entering Elf_Header::get_Relocation_Add_String" );

        std::stringstream output;
        output << "  Number of symbols: " << m_relocs_add.size() << std::endl;

        for ( typename elf_types::Elf_Header<bitsize>::Elf_Relocation_Add_List_t::iterator pos = m_relocs_add.begin();
              pos != m_relocs_add.end();
              ++pos )
            {
                output << (*pos)->to_String() << std::endl;
            }

        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Exiting Elf_Header::get_Relocation_Add_String" );

        return output.str();
    }

    template <boost::uint32_t bitsize>
    void
    Elf_Header<bitsize>::push_Back_Symbol ( typename elf_types::Elf_Symbol<bitsize>::ptr_t const sym )
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Entering Elf_Header::push_Back_Symbol" );

        m_symbol_table.push_back (sym);

        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Exiting Elf_Header::push_Back_Symbol" );
    }

    template <boost::uint32_t bitsize>
    Elf_Symbol<bitsize> const&
    Elf_Header<bitsize>::get_Symbol ( typename Type_Mapper<bitsize>::arch_t index )
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Entering Elf_Header::get_Symbol" );

        Elf_Symbol<bitsize> result;

        if (index <= m_symbol_table.size())
            {
                result = *(m_symbol_table[index]);
            }
        else
            {
                std::cerr << "ERROR:" << std::endl
                          << "  Index: " << index << std::endl
                          << "  No of symbols: " << m_symbol_table.size()
                          << std::endl;

                throw errors::File_Reader_Exception
                    (errors::File_Reader_Exception::OUT_OF_BOUNDS);
            }

        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Exiting Elf_Header::get_Symbol" );

        return result;
    }

    template <boost::uint32_t bitsize>
    Elf_Program_Header<bitsize> const&
    Elf_Header<bitsize>::get_Program_Header ( boost::uint32_t addr)
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Entering Elf_Header::get_Program_Header" );

        typename elf_types::Elf_Header<bitsize>::Elf_Program_Header_List_t::iterator pos;

        for ( pos = m_instruction_prg_hdrs.begin();
              pos != m_instruction_prg_hdrs.end();
              ++pos)
            {
                if ((*pos)->in_Range(addr))
                    {
                        break;
                    }
            }
        
        typename elf_types::Elf_Program_Header<bitsize>::ptr_t hdr_ptr = *pos;

        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Exiting Elf_Header::get_Program_Header" );

        return *hdr_ptr;
    }

    template <boost::uint32_t bitsize>
    typename Type_Mapper<bitsize>::arch_t const
    Elf_Header<bitsize>::get_Base_Address (void) const
    {
        Trace::write_Trace ( TraceArea::IO,
                             TraceLevel::DETAIL,
                             "Inside Elf_Header::get_Base_Address" );

        return m_base_address;
    }
  
} /* namespace elf_module */
} /* namespace libreverse */
