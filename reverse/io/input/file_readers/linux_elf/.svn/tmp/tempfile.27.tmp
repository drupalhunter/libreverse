#ifndef ELF_PROGRAM_HEADER_H_
#define ELF_PROGRAM_HEADER_H_

#include "libreverse/io/input/File_Readers/Base_Header.h"
#include "libreverse/io/Type_Mapper.h"

namespace libreverse { namespace elf_module {

    /*!
     * \class Elf_Program_Header
     * \date 2003
     * \author Stephen Torri
     *
     * (Elf) = Executable and Linkable Format specification
     */
    template <boost::uint32_t bitsize>
    class Elf_Program_Header : public header::Base_Header {

        friend class Elf_File<bitsize>;

    public:

        /*!
         * \brief Constructor
         * \param e_machine Target architecture
         */
        Elf_Program_Header ( boost::uint16_t e_machine );

        /*!
         * \brief Return the bit size of the header
         * \return Integer value of bit size (32/64)
         */
        virtual boost::uint32_t get_size (void) const;

        /*!
         * \brief Convert the bit order of the stored data if host and
         * data endian types differ
         */
        virtual void convert ();

        /*!
         * \brief Return the data of this header in a format style
         * \return String representation of data
         * The format style was taken from the readelf source code
         */
        std::string to_String (void);

        /*!
         * \brief Get the human readable strings from the header
         * \return String output of header
         */
        void get_Text_String ( io_types::Text_Data::data_type* output );

        boost::uint32_t get_Type ( void ) const;

        /*! \brief If the address for a data is contained within this
          program header we return TRUE. Otherwise FALSE.
        */
        bool in_Range ( typename Type_Mapper<bitsize>::arch_t addr );

        /*! \brief Get result of p_vaddr - p_offset */
        typename Type_Mapper<bitsize>::arch_t get_Address_Offset (void) const;

        typename Type_Mapper<bitsize>::arch_t get_Virtual_Address (void) const;

    private:

        /*!
         * \brief This member tells what kind of segment this array element
         * described or how to interpret the array element's
         * information. Type values and their meanings appear below. (Elf)
         */
        boost::uint32_t p_type;

        /*!
         * \brief This member gives the offset from the beginning of the
         * file at which the first byte of the segment resides. (Elf)
         */
        typename Type_Mapper<bitsize>::arch_t p_offset;

        /*!
         * \brief This member gives the virtual address at which the first
         * byte of the segment resides in memory.
         */
        typename Type_Mapper<bitsize>::arch_t p_vaddr;

        /*!
         * \brief On systems for which physical addressing is relevant, this
         * member is reserved for the segment's physical address. Because
         * System V ignores physical addressing for application programs,
         * this member has unspecified contents for executable files and
         * shared objects. (Elf)
         */
        typename Type_Mapper<bitsize>::arch_t p_paddr;

        /*!
         * \brief This member gives the number of bytes in the file image of
         * the segment; it may be zero. (Elf)
         */
        typename Type_Mapper<bitsize>::arch_t p_filesz;

        /*!
         * \brief This member gives the number of bytes in the memory image
         * of the segment; it may be zero. (Elf)
         */
        typename Type_Mapper<bitsize>::arch_t p_memsz;

        /*!
         * \brief This member gives the flags relevant to the segment. (Elf)
         */
        typename Type_Mapper<bitsize>::arch_t p_flags;

        /*!
         * \brief This member gives the value to which the segments are
         * aligned in memory and in the file. Values 0 and 1 mean no
         * alignment is required. Otherwise, p_align should be positive,
         * integral power of 2, and p_vaddr should equal p_offset modulo
         * p_align. (Elf)
         */
        typename Type_Mapper<bitsize>::arch_t p_align;

        //----------------------------------------
        //      ELF HEADER helper variables
        //----------------------------------------

        /*! \brief Machine architecture */
        boost::uint16_t m_e_machine;

        //----------------------------------------
        //      ELF HEADER helper functions
        //----------------------------------------
        std::string get_segment_type (void);

        std::string get_mips_segment_type (void);

        std::string get_parisc_segment_type (void);

        std::string get_ia64_segment_type (void);

    };

} /* namespace elf_module */
} /* namespace libreverse */

#include "Elf_Program_Header_T.cpp"

#endif /* ELF_PROGRAM_HEADER_H_ */
