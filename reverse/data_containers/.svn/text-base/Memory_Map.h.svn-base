/*  Memory_Map.h

   Copyright (C) 2008 Stephen Torri

   This file is part of Libreverse.

   Libreverse is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation; either version 3, or (at your
   option) any later version.

   Libreverse is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see
   <http://www.gnu.org/licenses/>.
*/

#ifndef MEMORY_MAP_H_
#define MEMORY_MAP_H_

#include <boost/shared_ptr.hpp>
#include <iostream>
#include <iomanip>
#include <vector>
#include <map>
#include <boost/enable_shared_from_this.hpp>
#include "Data_Types.h"

namespace libreverse
{
    namespace data_container
    {

        class Memory_Map : public boost::enable_shared_from_this<Memory_Map>
        {
            public:

                /**
                 * \brief Set up a blank memory map of a set size
                 *
                 * \param size Size of memory map to allocate
                 *
                 * \param base_address The memory address of the first byte
                 *
                 * \pre size has a value of 0 or more
                 *
                 * \pre base_address has a value of 0 or more
                 *
                 * \post Size of memory map has been set to the value of the
                 * input variable 'size'
                 *
                 * \post Base addres of the memory map has been set to the
                 * value of the input variable 'base_address' or the default
                 * value of zero
                 */
                explicit Memory_Map ( boost::uint32_t size,
                                      boost::uint32_t base_address = 0 );

                /**
                 * \brief Set up a memory map of a set size with the contents
                 * of the input file stream.
                 *
                 * \param input_ref Input file stream where data is stored.
                 *
                 * \param base_address The memory address of the first byte
                 *
                 * \pre size has a value of 0 or more
                 *
                 * \pre base_address has a value of 0 or more
                 *
                 * \post Size of memory map has been set to the value of the
                 * size of the input file stream.
                 *
                 * \post Base addres of the memory map has been set to the
                 * value of the input variable 'base_address' or the default
                 * value of zero
                 */
                explicit Memory_Map ( std::ifstream& input_ref,
                                      boost::uint32_t base_address = 0 );

                /**
                 * \brief Copy constructor
                 *
                 * \pre The input reference is a fully initialized Memory_Map
                 *
                 * \post The output Memory_Map is a deep copy of the input
                 */
                explicit Memory_Map ( Memory_Map const& rhs );

                virtual ~Memory_Map();

                /**
                 * \brief assignment operator
                 *
                 * This function handles copying the rhs reference even if the rhs
                 * is a reference to this object.
                 *
                 * \pre The input reference is a fully initialized Memory_Map
                 *
                 * \post The output Memory_Map is a deep copy of the input
                 */
                Memory_Map& operator= ( Memory_Map const& rhs );

                /**
                 * \brief assignment operator
                 *
                 * \pre The input reference is a fully initialized Memory_Map
                 *
                 * \post The output Memory_Map is a deep copy of the input
                 */
                void swap ( Memory_Map& rhs );

                /**
                 * \brief Adjust the pointer into the memory to the location
                 * specified in by the address.
                 *
                 * \post The present position is set to the new location.
                 */
                boost::int8_t address_Seek ( boost::uint32_t address );

                /**
                 * \brief Adjust the pointer into the memory to the location
                 * specified in by the index.
                 *
                 * \post The present position is set to the new location.
                 */
                template <typename Offset_Type>
                boost::int8_t
                index_Seek ( Offset_Type offset )
                {
                    if ( offset > m_data.size() - 1 )
                    {
                        std::cerr << "The offset given, " << offset
                        << " is invalid. Its pointing to a "
                        << std::endl
                        << "memory location outside of space "
                        << "allocated to"
                        << std::endl
                        << "this Memory Map. ("
                        << m_data.size() << ")"
                        << std::endl;

                        return data_types::Memory_Map::OUT_OF_RANGE;
                    }

                    m_present_pos = offset;

                    return data_types::Memory_Map::SUCCESS;
                }

                /**
                 * \brief Read 'length' units of data from this Memory Map.
                 *
                 * The read data will be placed into the destination startin
                 * at the beginning.
                 *
                 * \pre The destination pointer is initialized.
                 *
                 * \pre Read length is non-zero
                 *
                 * \post The present position is set to the new location.
                 */
                boost::int8_t read ( data_types::Memory_Map::pointer_t dest_addr_ptr,
                                     boost::uint32_t length );

                /**
                 * \brief This copies from the src_ptr to the local Memory
                 * Map. It is assumed that the local Memory Map has been
                 * adjusted to the position where data will be store. It is
                 * also assumed that the src_ptr has been adjusted to the
                 * position where we will start reading data.
                 *
                 * \pre The destination pointer is initialized.
                 *
                 * \pre Read length is non-zero
                 *
                 * \post The present position is set to the new location.
                 */
                boost::int8_t copy ( data_types::Memory_Map::ptr_t src_ptr,
                                     boost::uint32_t length );

                /**
                 * \brief This produces a new Memory Map containing a subset
                 * of the parent map. It is assumed that the parent Memory Map
                 * has been adjusted to the position where we will start
                 * reading data.
                 *
                 * \pre Present Position of the pointer into the data will not
                 * go past the boundary with the given length.
                 *
                 * \pre Length is non-zero
                 */
                std::pair <data_types::Memory_Map::ptr_t, boost::int8_t>
                subset ( boost::uint32_t length );

                data_types::Memory_Map::iterator begin();

                data_types::Memory_Map::const_iterator begin() const;

                data_types::Memory_Map::const_iterator end() const;

                boost::uint32_t get_Present_Position_Value ( void ) const;

                data_types::Memory_Map::const_iterator get_Present_Position ( void ) const;

                boost::uint32_t get_Present_Position_Address ( void ) const;

                boost::uint32_t get_Position_Address ( data_types::Memory_Map::const_iterator ) const;

                boost::uint32_t get_Previous_Position_Value ( void ) const;

                data_types::Memory_Map::const_iterator get_Previous_Position ( void ) const;

                boost::uint32_t get_Previous_Position_Address ( void ) const;

                boost::uint32_t size ( void ) const;

                std::string to_String ( void ) const;

                bool operator== ( Memory_Map& rhs_ref ) const;

                bool allocate_Range ( boost::uint32_t address, boost::uint32_t size );

            private:

                Memory_Map();

                data_types::Memory_Map::Values_t m_data;

                boost::uint32_t m_present_pos; // Present index

                boost::uint32_t m_previous_pos; // Previous index

                boost::uint32_t m_base_address;

        };

    } /* namespace data_types */
} /* namespace libreverse */

#endif /* MEMORY_MAP_H_ */
