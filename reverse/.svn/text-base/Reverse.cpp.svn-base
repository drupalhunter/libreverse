/*  Reverse.cpp

   Copyright (C) 2008 Stephen Torri

   This file is part of Libreverse.

   Libreverse is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation; either version 3, or (at your
   option) any later version.

   Libreverse is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see
   <http://www.gnu.org/licenses/>.
*/

#include "Reverse.h"
#include "api/Reverse_Impl.h"
#include "infrastructure/data_source/Memory_Data_Transfer.h"
#include "infrastructure/data_source/Memory_Data_Source_Config.h"
#include "infrastructure/data_source/Data_Source_T.h"
#include "infrastructure/Configurator.h"
#include "components/Component_Factory.h"
#include "infrastructure/Component_State.h"
#include "components/Null_Component.h"
#include "libreverse/errors/Reverse_Exception.h"
#include <boost/filesystem/operations.hpp>
#include "libreverse/errors/Parsing_Exception.h"

#ifdef LIBREVERSE_DEBUG
#include "Trace.h"
using namespace libreverse::trace;
#endif /* LIBREVERSE_DEBUG */

namespace libreverse { namespace api {

    Reverse::Reverse ()
    {}

    Reverse::~Reverse ()
    {}

    boost::int32_t
    Reverse::execute ( std::string target_file,
                       Input_Types::Values input_type,
                       Output_Types::Values output_type,
                       TraceLevel::Values trace_level,
                       TraceArea::Values trace_mask )
    {

#ifdef LIBREVERSE_DEBUG
        if ( trace_level != TraceLevel::NONE )
            {
                Trace_State::Instance().set_Trace_Level ( trace_level );
                Trace_State::Instance().set_Trace_Area_Mask ( trace_mask );
                Trace_State::Instance().open_Trace_File ();
            }
#endif /* LIBREVERSE_DEBUG */

        boost::int32_t result = Results::SUCCESS;

        if ( target_file.empty() )
            {
                result = Results::FAILURE;
                return result;
            }

        if ( ! ( boost::filesystem::exists ( target_file ) ) )
            {
                result = Results::FAILURE;
                return result;
            }

        if ( ! ( this->valid_Types ( Input_Types::BINARY,
                                     Input_Types::BINARY,
                                     input_type ) ) )
            {
                result = Results::FAILURE;
                return result;
            }

        if ( ! ( this->valid_Types ( Output_Types::CPLUSPLUS,
                                     Output_Types::UML,
                                     output_type ) ) )
            {
                result = Results::FAILURE;
                return result;
            }

        try {

            //------------------------------
            // Prepare Initial Component
            //------------------------------
            // Create a Null Component object
            // Set output meta information to "target_filename"
            // Pass component object with meta information to execute_Input_Section
            infrastructure_types::Component_State::ptr_t state_ptr ( new infrastructure::Component_State
                                                                     ( infrastructure::Component::SOURCE_ID ) );

            infrastructure_types::Component::ptr_t comp_ptr =
                infrastructure::Component_Factory::Instance().get_Null_Component ( state_ptr );

            //------------------------------
            // Prepare Initial Data Source
            //------------------------------

            // The first component will receive its data via a file. The rest
            // of the components will receive it by memory for now. So we
            // create the input data source (file type)
            infrastructure_types::Memory_Data_Source_Config::ptr_t mem_config (new infrastructure::Memory_Data_Source_Config ());

            infrastructure_types::Memory_Data_Transfer::ptr_t mem_ptr ( new infrastructure::Memory_Data_Transfer (mem_config));

            boost::shared_ptr < infrastructure::Data_Source
                < infrastructure::Memory_Data_Transfer > >
                input_data  (new infrastructure::Data_Source < infrastructure::Memory_Data_Transfer >(mem_ptr));

            infrastructure_types::Data_Object::ptr_t input_data_source_ptr ( new infrastructure::Data_Object() );

            data_types::Filename::const_ptr_t file_ptr ( new data_container::Filename ( target_file ) );

            input_data_source_ptr->set_Data ( file_ptr );

            input_data->put ( input_data_source_ptr );

            // Create component graph from suggested configuration files
            //  Configuration files are in three parts
            infrastructure_types::Component_Graph::Map_ptr_t m_graph =
	      (infrastructure::Configurator::Instance()).get_Graph (input_type, output_type);

            Reverse_Impl m_executor;

            // ----------------------------------------
            //             INPUT Section
            // ----------------------------------------
            //
            // Input: Change input to send a Component with meta information
            //
            // Output: Change return type to give back a pair < Data_Source_Base, Component>
            // which contains the output data and the last component
            Reverse_Impl::Return_Type_t input_results_ptr =
                m_executor.execute_Input_Section ( m_graph, input_data, comp_ptr );


            // FUTURE: We could take the meta information from the
            // Input analysis phase and make decisions on it. For
            // example, choose the type of analysis graph to use based
            // on the compiler used to create the target executable.

            // ----------------------------------------
            //             ANALYSIS Section
            // ----------------------------------------
            // Input: Change input to send the component retrieved from the input section
            //
            // Change return type to give back a pair < Data_Source_Base, Component>
            // which contains the output data and the last component
            Reverse_Impl::Return_Type_t analysis_results_ptr =
                m_executor.execute_Analysis_Section ( m_graph, input_results_ptr );

            // ----------------------------------------
            //             OUTPUT Section
            // ----------------------------------------
            // Input: Change input to send the component retrieved from the input section
            m_executor.execute_Output_Section ( m_graph, analysis_results_ptr );

        }
        catch ( errors::Reverse_Exception& re )
            {
                std::cerr << boost::format("Exception:(%d) %s")
                    % re.name()
                    % re.id() << std::endl;
                std::cerr << re.what() << std::endl;

                result = Results::FAILURE;
                return result;
            }

#ifdef LIBREVERSE_DEBUG
        if ( trace_level != TraceLevel::NONE )
            {
                Trace_State::Instance().close_Trace_File ();
            }
#endif /* LIBREVERSE_DEBUG */

        return result;

    }


    bool Reverse::valid_Types ( boost::uint32_t lower_limit,
                                boost::uint32_t upper_limit,
                                boost::uint32_t value )
    {
        bool result = false;

        if ( ( lower_limit <= value ) &&
             ( value <= upper_limit ) )
            {
                result = true;
            }

        return result;
    }

} /* namespace api */
} /* namespace libreverse */
