/*  Trace.cpp

   Copyright (C) 2008 Stephen Torri

   This file is part of Libreverse.

   Libreverse is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation; either version 3, or (at your
   option) any later version.

   Libreverse is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see
   <http://www.gnu.org/licenses/>.
*/

#include "Trace.h"
#include <boost/format.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <sstream>
#include "libreverse/errors/Internal_Exception.h"

#ifndef WIN32
#include <unistd.h>
#else
#include <windows.h>
#endif /* WIN32 */

namespace libreverse { namespace trace {

    Trace_State& Trace_State::Instance()
    {
        static Trace_State instance_obj;
        return instance_obj;
    }

    void
    Trace_State::set_Trace_File_Name ( std::string name )
    {
      if ( ! name.empty() )
	{
	  m_file_name = name;
	}
      else
	{
	  throw errors::Internal_Exception ( errors::Internal_Exception::EMPTY_STRING );
	}
    }

    void
    Trace_State::set_Trace_File_Prefix ( std::string name )
    {
      if ( ! name.empty() )
	{
	  m_file_prefix = name;
	}
      else
	{
	  throw errors::Internal_Exception ( errors::Internal_Exception::EMPTY_STRING );
	}
    }

    bool
    Trace_State::is_Valid_Level ( boost::uint32_t lvl )
    {       
        switch ( lvl )
            {
            case api::TraceLevel::NONE:
            case api::TraceLevel::WARN:
            case api::TraceLevel::ERROR:
            case api::TraceLevel::INFO:
            case api::TraceLevel::DEBUG:
            case api::TraceLevel::DETAIL:
            case api::TraceLevel::DATA:
                {
                    return true;
                }
            default:
                {
                    return false;
                }
            }
    }

    bool
    Trace_State::is_Valid_Area_Mask ( boost::uint32_t )
    {       
        // Since we are using all the bits of the 8-bit byte any
        // combination of bits will be valid. Therefore we return
        // TRUE. In the future we may need to expand the bit mask
        // therefore there might be reason to check the given mask
        // later.
        return true;
    }

    void
    Trace_State::set_Trace_Level ( boost::uint32_t level )
    {
        if ( this->is_Valid_Level ( level ) )
            {
                m_trace_level = level;
            }
        else
            {
                throw errors::Internal_Exception ( errors::Internal_Exception::INVALID_VALUE );
            }
    }

    void
    Trace_State::set_Trace_Area_Mask ( boost::uint32_t mask )
    {
        if ( this->is_Valid_Area_Mask ( mask ) )
            {
                m_trace_area_mask = mask;
            }
        else
            {
                throw errors::Internal_Exception ( errors::Internal_Exception::INVALID_VALUE );
            }
    }

    void
    Trace_State::open_Trace_File ( void )
    {
        if ( ! m_log_stream.is_open() )
            {
	      if ( m_file_name.empty() )
		{
		  // Create file name
		  std::stringstream name;

		  name << boost::format("%s_%s.txt")
		    % m_file_prefix
		    % this->get_ID_String();
		  
		  m_file_name = name.str();
		}
                
                m_log_stream.open ( m_file_name.c_str() );
            }
    }

    std::string
    Trace_State::get_ID_String ( void )
    {
        // Create id string
        std::stringstream name;

        // Get current time
        boost::posix_time::ptime now = boost::posix_time::second_clock::local_time();

        std::tm tm_ref = boost::posix_time::to_tm ( now );

        boost::gregorian::date today = now.date();

        name << boost::format ( "%1%_%2%:%3%:%4%" )
            % boost::gregorian::to_iso_extended_string ( today )
            % tm_ref.tm_hour
            % tm_ref.tm_min
            % tm_ref.tm_sec;

        return name.str();
    }

    void
    Trace_State::close_Trace_File ( void )
    {
        if ( m_log_stream.is_open() )
            {
                m_log_stream.close();
            }
    }

    boost::uint32_t
    Trace_State::get_Trace_Level ( void ) const
    {
        return m_trace_level;
    }

    boost::uint32_t
    Trace_State::get_Trace_Area_Mask ( void ) const
    {
        return m_trace_area_mask;
    }

    void
    Trace_State::write_Message ( boost::uint32_t level, std::string msg )
    {
        // Write ID
        m_log_stream << boost::format("%s_%d: " )
	  % this->get_ID_String()
#ifndef WIN32
	  % getpid()
#else
	  % GetCurrentProcessId()
#endif /* WIN32 */
                     << std::flush;
            
        // Write message prefix
        if ( level == api::TraceLevel::WARN )
            {
                m_log_stream << "(WW) ";
            }
        else if ( level == api::TraceLevel::ERROR )
            {
                m_log_stream << "(EE) ";
            }
        else if ( level == api::TraceLevel::INFO )
            {
                m_log_stream << "(II) ";
            }
        else if ( level == api::TraceLevel::DEBUG )
            {
                m_log_stream << "(DEBUG) ";
            }
        else if ( level == api::TraceLevel::DETAIL )
            {
                m_log_stream << "(DETAIL) ";
            }
        else if ( level == api::TraceLevel::DATA )
            {
                m_log_stream << "(DATA) ";
            }
        else 
            {
                // We should not be here
                abort();
            }

        // Write to the file
        m_log_stream << msg << std::endl << std::flush;

        // Unlock the resource
    }
    
    Trace_State::Trace_State()
        : m_file_prefix ( "Trace" ),
      m_file_name ( "" ),
      m_trace_level ( api::TraceLevel::NONE ),
      m_trace_area_mask ( api::TraceArea::NONE )
    {}

    Trace_State::~Trace_State()
    {
        this->close_Trace_File();
    }

#ifdef LIBREVERSE_DEBUG
    bool
    Trace::write_Trace ( boost::uint32_t area, 
                         boost::uint32_t level,
                         std::string message )
    {
        if ( ! Trace_State::Instance().is_Valid_Level ( level ) )
            {
                throw errors::Internal_Exception ( errors::Internal_Exception::INVALID_VALUE );
            }

        if ( message.empty() )
            {
                throw errors::Internal_Exception ( errors::Internal_Exception::EMPTY_STRING );
            }

        if ( ! Trace_State::Instance().is_Valid_Area_Mask ( area ) )
            {
                throw errors::Internal_Exception ( errors::Internal_Exception::INVALID_VALUE );
            }

        // If the level is equal to or greater than the present
        // level we record out message.
        if ( ( Trace_State::Instance().get_Trace_Level() != api::TraceLevel::NONE ) && 
             ( level <= Trace_State::Instance().get_Trace_Level() ) &&
             ( ( Trace_State::Instance().get_Trace_Area_Mask() & area ) != 0 ) )
            {
                Trace_State::Instance().write_Message ( level, message );
            }

        return true;
    }
#else
    bool
    Trace::write_Trace ( boost::uint32_t,
                         boost::uint32_t,
                         std::string )
    {
        return true;
    }
#endif

} /* namespace trace */
} /* namespace trace */

