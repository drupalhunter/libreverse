/*  Java_Training_Data.cpp

   Copyright (C) 2008 Stephen Torri

   This file is part of Libreverse.

   Libreverse is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation; either version 3, or (at your
   option) any later version.

   Libreverse is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see
   <http://www.gnu.org/licenses/>.
*/

//
// C++ Implementation: Training_Data
//
// Description:
//
//
// Author: Stephen Torri, Winard Britt <storri@dell>, (C) 2007
//
// Copyright: See COPYING file that comes with this distribution
//
//
#include "Java_Training_Data.h"
#include "libreverse/errors/Internal_Exception.h"
#include "Configuration.h"
#include <sstream>
#include <iostream>
#include <boost/format.hpp>

#include "libreverse/Reverse.h"
#include "libreverse/Trace.h"

using namespace libreverse::api;
using namespace libreverse::trace;

namespace libreverse
{
  namespace classifier
  {

    const boost::uint8_t Java_Training_Data::ATTRIBUTE_COUNT = 32;
    const boost::uint8_t Java_Training_Data::CLASSIFIER_TARGET = Java_Training_Data::ATTRIBUTE_COMPILER_ID;

    Java_Training_Data::Java_Training_Data ()
    {
      Trace::write_Trace ( TraceArea::GRNN_DATA,
			   TraceLevel::DETAIL,
			   "Inside Java_Training_Data constructor" );
    }

    Java_Training_Data::~Java_Training_Data ()
    {
      Trace::write_Trace ( TraceArea::GRNN_DATA,
			   TraceLevel::DETAIL,
			   "Inside Java_Training_Data destructor" );
    }

    classifier_types::Variable_Map::map_type
    Java_Training_Data::get_Candidate_Data ( classifier_types::Configuration<Java_Training_Data>::ptr_t config ) const
    {
      Trace::write_Trace ( TraceArea::GRNN_DATA,
			   TraceLevel::DETAIL,
			   "Entering Java_Training_Data::get_Candidate_Data" );

      classifier_types::Variable_Map::map_type output;

      for ( boost::uint32_t index = 0;
	    index < Java_Training_Data::ATTRIBUTE_COUNT;
	    ++index )
        {
	  if ( config->get_Attribute ( index ) )
            {
	      classifier_types::Variable_Map::map_type::const_iterator pos = m_data.find ( index );
	      output[index] = ( *pos ).second;
            }
        }

      Trace::write_Trace ( TraceArea::GRNN_DATA,
			   TraceLevel::DETAIL,
			   "Exiting Java_Training_Data::get_Candidate_Data" );

      return output;
    }

    std::string
    Java_Training_Data::get_Attribute_String_List ( classifier_types::Configuration<Java_Training_Data>::ptr_t config )
    {
      Trace::write_Trace ( TraceArea::GRNN_DATA,
			   TraceLevel::DETAIL,
			   "Entering Java_Training_Data::to_String" );
      
      std::stringstream output;

      output << boost::format ( "Java_Training_Data #%1%" ) % index << std::endl;
	
      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_COMPILER_ID ) )
        {
	  output << "Compiler_ID" << std::endl;
        }

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_FILESIZE ) )
        {
	  output << "Filesize" << std::endl;
        }
        
      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_THIS_INDEX ) )
        {
	  output << "This_index" << std::endl;
        }
        
      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_SUPER_INDEX ) )
        {
	  output << "Super_index" << std::endl;
        }
        
      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_VERSION ) )
        {
	  output << "Version" << std::endl;
        }
        
      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_POOL_COUNT ) )
        {
	  output << "Constant Pool count" << std::endl;
        }

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_UTF8_COUNT ) )
	{
	  output << "Constant UTF-8 count" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_UTF8_RATIO ) )
	{
	  output << "Constant UTF-8 ratio" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_RESERVED_COUNT ) )
	{
	  output << "Reserved count" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_RESERVED_RATIO ) )
	{
	  output << "Reserved ratio" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_INTEGER_COUNT ) )
	{
	  output << "Constant Pool Integer count" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_INTEGER_RATIO ) )
	{
	  output << "Constant Pool Integer ratio" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_FLOAT_COUNT ) )
	{
	  output << "Constant Pool Float count" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_FLOAT_RATIO ) )
	{
	  output << "Constant Pool Float ratio" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_LONG_COUNT ) )
	{
	  output << "Constant Pool Long count" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_LONG_RATIO ) )
	{
	  output << "Constant Pool Long ratio" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_DOUBLE_COUNT ) )
	{
	  output << "Constant Pool Double count" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_DOUBLE_RATIO ) )
	{
	  output << "Constant Pool Double ratio" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_CLASS_COUNT ) )
	{
	  output << "Constant Pool Class count" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_CLASS_RATIO ) )
	{
	  output << "Constant Pool Class ratio" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_STRING_COUNT ) )
	{
	  output << "Constant Pool String count" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_STRING_RATIO ) )
	{
	  output << "Constant Pool String ratio" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_FIELDREF_COUNT ) )
	{
	  output << "Constant Pool Fieldref count" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_FIELDREF_RATIO ) )
	{
	  output << "Constant Pool Fieldref ratio" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_METHODREF_COUNT ) )
	{
	  output << "Constant Pool Methodref count" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_METHODREF_RATIO ) )
	{
	  output << "Constant Pool Methodref ratio" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_INTERFACE_METHODREF_COUNT ) )
	{
	  output << "Constant Pool Interface Methodref count" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_INTERFACE_METHODREF_RATIO ) )
	{
	  output << "Constant Pool Interface Methodref ratio" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_NAME_AND_TYPE_COUNT ) )
	{
	  output << "Constant Pool Name and Type count" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_CONSTANT_NAME_AND_TYPE_RATIO ) )
	{
	  output << "Constant Pool Name and Type ratio" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_FIELD_COUNT ) )
        {
	  output << "Field Count" << std::endl;
	}

      if ( config->get_Attribute ( Java_Training_Data::ATTRIBUTE_METHOD_COUNT ) )
        {
	  output << "Method Count" << std::endl;
	}

      Trace::write_Trace ( TraceArea::GRNN_DATA,
			   TraceLevel::DETAIL,
			   "Exiting Java_Training_Data::to_String" );

      return output.str();
    }

    std::string
    Java_Training_Data::to_String ( boost::uint32_t index ) const
    {
      Trace::write_Trace ( TraceArea::GRNN_DATA,
			   TraceLevel::DETAIL,
			   "Entering Java_Training_Data::to_String" );

      std::stringstream output;

      output << boost::format ( "Java_Training_Data #%1%" ) % index << std::endl
	     << boost::format ( "  compiler id...........: %1%" )
        % ( *m_data.find ( ATTRIBUTE_COMPILER_ID ) ).second << std::endl
	     << boost::format ( "  file size.............: %1% bytes" )
        % ( *m_data.find ( ATTRIBUTE_FILESIZE ) ).second  << std::endl
	     << boost::format ( "  this index............: %1%" )
        %  ( *m_data.find ( ATTRIBUTE_THIS_INDEX ) ).second << std::endl
	     << boost::format ( "  super index...........: %1%" )
        %  ( *m_data.find ( ATTRIBUTE_SUPER_INDEX ) ).second << std::endl
	     << boost::format ( "  version...............: %1%" )
        %  ( *m_data.find ( ATTRIBUTE_VERSION ) ).second << std::endl
	     << boost::format ( "  constant pool count...: %1%" )
        %  ( *m_data.find ( ATTRIBUTE_CONSTANT_POOL_COUNT ) ).second
	     << std::endl
	     << "  Constant Pool" << std::endl;

      // For all constant pool info from UTF8 to NAME_AND_TYPE
      // print (index = tag, count, ratio)
      boost::uint32_t pool_index = ATTRIBUTE_CONSTANT_UTF8_COUNT; // 6
      boost::uint32_t tag_count = 1;

      while ( pool_index <= ATTRIBUTE_CONSTANT_NAME_AND_TYPE_RATIO )
        {
	  output << boost::format ( "      tag(%1$d) = %2$d (%3$f)" ) % tag_count++
            %  ( *m_data.find ( pool_index ) ).second
            % ( *m_data.find ( pool_index + 1 ) ).second << std::endl;
	  pool_index += 2;
        }

      output << boost::format ( "  field count...........: %1%" )
        %  ( *m_data.find ( ATTRIBUTE_FIELD_COUNT ) ).second << std::endl
	     << boost::format ( "  method count..........: %1%" )
        %  ( *m_data.find ( ATTRIBUTE_METHOD_COUNT ) ).second << std::endl;

      Trace::write_Trace ( TraceArea::GRNN_DATA,
			   TraceLevel::DETAIL,
			   "Exiting Java_Training_Data::to_String" );

      return output.str();
    }

    classifier_types::Variable_Map::map_type::const_iterator
    Java_Training_Data::begin ( void ) const
    {
      Trace::write_Trace ( TraceArea::GRNN_DATA,
			   TraceLevel::DETAIL,
			   "Inside Java_Training_Data::begin (const)" );

      return m_data.begin();
    }

    classifier_types::Variable_Map::map_type::iterator
    Java_Training_Data::begin ( void )
    {
      Trace::write_Trace ( TraceArea::GRNN_DATA,
			   TraceLevel::DETAIL,
			   "Inside Java_Training_Data::begin" );

      return m_data.begin();
    }

    classifier_types::Variable_Map::map_type::const_iterator
    Java_Training_Data::end ( void ) const
    {
      Trace::write_Trace ( TraceArea::GRNN_DATA,
			   TraceLevel::DETAIL,
			   "Inside Java_Training_Data::end (const)" );

      return m_data.end();
    }

    classifier_types::Variable_Map::map_type::iterator
    Java_Training_Data::end ( void )
    {
      Trace::write_Trace ( TraceArea::GRNN_DATA,
			   TraceLevel::DETAIL,
			   "Inside Java_Training_Data::end" );

      return m_data.end();
    }

    void
    Java_Training_Data::set_Attribute ( boost::uint32_t index, double value )
    {
      if ( index < Java_Training_Data::ATTRIBUTE_COUNT )
	{
          m_data[index] = value;
	}
    }

    double
    Java_Training_Data::get_Attribute ( boost::uint32_t index )
    {
      if ( index < Java_Training_Data::ATTRIBUTE_COUNT )
	{
          return m_data[index];
	}
      else
	{
	  throw errors::Internal_Exception ( errors::Internal_Exception::INVALID_INDEX );
	}
    }
  } /* namespace classifier */
} /* namespace libreverse */
